package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/repository.Repository -o ./mocks/repository_minimock.go -n RepositoryMock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements repository.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCancelOrder          func(ctx context.Context, orderID models.OrderID) (err error)
	inspectFuncCancelOrder   func(ctx context.Context, orderID models.OrderID)
	afterCancelOrderCounter  uint64
	beforeCancelOrderCounter uint64
	CancelOrderMock          mRepositoryMockCancelOrder

	funcCreateOrder          func(ctx context.Context, createOrder models.CreateOrder) (o1 models.OrderID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, createOrder models.CreateOrder)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mRepositoryMockCreateOrder

	funcGetOrderStatus          func(ctx context.Context, orderID models.OrderID) (s1 models.Status, err error)
	inspectFuncGetOrderStatus   func(ctx context.Context, orderID models.OrderID)
	afterGetOrderStatusCounter  uint64
	beforeGetOrderStatusCounter uint64
	GetOrderStatusMock          mRepositoryMockGetOrderStatus

	funcGetOrderUser          func(ctx context.Context, orderID models.OrderID) (u1 models.User, err error)
	inspectFuncGetOrderUser   func(ctx context.Context, orderID models.OrderID)
	afterGetOrderUserCounter  uint64
	beforeGetOrderUserCounter uint64
	GetOrderUserMock          mRepositoryMockGetOrderUser

	funcGetOutbox          func(ctx context.Context) (oa1 []models.Outbox, err error)
	inspectFuncGetOutbox   func(ctx context.Context)
	afterGetOutboxCounter  uint64
	beforeGetOutboxCounter uint64
	GetOutboxMock          mRepositoryMockGetOutbox

	funcGetStocks          func(ctx context.Context, sku uint32) (sp1 *models.Stocks, err error)
	inspectFuncGetStocks   func(ctx context.Context, sku uint32)
	afterGetStocksCounter  uint64
	beforeGetStocksCounter uint64
	GetStocksMock          mRepositoryMockGetStocks

	funcGetUnpayedOrdersWithinTimeout          func(ctx context.Context) (oa1 []models.OrderID, err error)
	inspectFuncGetUnpayedOrdersWithinTimeout   func(ctx context.Context)
	afterGetUnpayedOrdersWithinTimeoutCounter  uint64
	beforeGetUnpayedOrdersWithinTimeoutCounter uint64
	GetUnpayedOrdersWithinTimeoutMock          mRepositoryMockGetUnpayedOrdersWithinTimeout

	funcListOrder          func(ctx context.Context, orderID models.OrderID) (op1 *models.Order, err error)
	inspectFuncListOrder   func(ctx context.Context, orderID models.OrderID)
	afterListOrderCounter  uint64
	beforeListOrderCounter uint64
	ListOrderMock          mRepositoryMockListOrder

	funcReduceStock          func(ctx context.Context, orderID models.OrderID) (err error)
	inspectFuncReduceStock   func(ctx context.Context, orderID models.OrderID)
	afterReduceStockCounter  uint64
	beforeReduceStockCounter uint64
	ReduceStockMock          mRepositoryMockReduceStock

	funcReserveStocks          func(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID) (err error)
	inspectFuncReserveStocks   func(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID)
	afterReserveStocksCounter  uint64
	beforeReserveStocksCounter uint64
	ReserveStocksMock          mRepositoryMockReserveStocks

	funcSetOutbox          func(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status) (err error)
	inspectFuncSetOutbox   func(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status)
	afterSetOutboxCounter  uint64
	beforeSetOutboxCounter uint64
	SetOutboxMock          mRepositoryMockSetOutbox

	funcUpdateOrderStatus          func(ctx context.Context, orderID []models.OrderID, status models.Status) (err error)
	inspectFuncUpdateOrderStatus   func(ctx context.Context, orderID []models.OrderID, status models.Status)
	afterUpdateOrderStatusCounter  uint64
	beforeUpdateOrderStatusCounter uint64
	UpdateOrderStatusMock          mRepositoryMockUpdateOrderStatus

	funcUpdateOutbox          func(ctx context.Context, ids []models.OutboxID) (err error)
	inspectFuncUpdateOutbox   func(ctx context.Context, ids []models.OutboxID)
	afterUpdateOutboxCounter  uint64
	beforeUpdateOutboxCounter uint64
	UpdateOutboxMock          mRepositoryMockUpdateOutbox
}

// NewRepositoryMock returns a mock for repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelOrderMock = mRepositoryMockCancelOrder{mock: m}
	m.CancelOrderMock.callArgs = []*RepositoryMockCancelOrderParams{}

	m.CreateOrderMock = mRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*RepositoryMockCreateOrderParams{}

	m.GetOrderStatusMock = mRepositoryMockGetOrderStatus{mock: m}
	m.GetOrderStatusMock.callArgs = []*RepositoryMockGetOrderStatusParams{}

	m.GetOrderUserMock = mRepositoryMockGetOrderUser{mock: m}
	m.GetOrderUserMock.callArgs = []*RepositoryMockGetOrderUserParams{}

	m.GetOutboxMock = mRepositoryMockGetOutbox{mock: m}
	m.GetOutboxMock.callArgs = []*RepositoryMockGetOutboxParams{}

	m.GetStocksMock = mRepositoryMockGetStocks{mock: m}
	m.GetStocksMock.callArgs = []*RepositoryMockGetStocksParams{}

	m.GetUnpayedOrdersWithinTimeoutMock = mRepositoryMockGetUnpayedOrdersWithinTimeout{mock: m}
	m.GetUnpayedOrdersWithinTimeoutMock.callArgs = []*RepositoryMockGetUnpayedOrdersWithinTimeoutParams{}

	m.ListOrderMock = mRepositoryMockListOrder{mock: m}
	m.ListOrderMock.callArgs = []*RepositoryMockListOrderParams{}

	m.ReduceStockMock = mRepositoryMockReduceStock{mock: m}
	m.ReduceStockMock.callArgs = []*RepositoryMockReduceStockParams{}

	m.ReserveStocksMock = mRepositoryMockReserveStocks{mock: m}
	m.ReserveStocksMock.callArgs = []*RepositoryMockReserveStocksParams{}

	m.SetOutboxMock = mRepositoryMockSetOutbox{mock: m}
	m.SetOutboxMock.callArgs = []*RepositoryMockSetOutboxParams{}

	m.UpdateOrderStatusMock = mRepositoryMockUpdateOrderStatus{mock: m}
	m.UpdateOrderStatusMock.callArgs = []*RepositoryMockUpdateOrderStatusParams{}

	m.UpdateOutboxMock = mRepositoryMockUpdateOutbox{mock: m}
	m.UpdateOutboxMock.callArgs = []*RepositoryMockUpdateOutboxParams{}

	return m
}

type mRepositoryMockCancelOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCancelOrderExpectation
	expectations       []*RepositoryMockCancelOrderExpectation

	callArgs []*RepositoryMockCancelOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockCancelOrderExpectation specifies expectation struct of the Repository.CancelOrder
type RepositoryMockCancelOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCancelOrderParams
	results *RepositoryMockCancelOrderResults
	Counter uint64
}

// RepositoryMockCancelOrderParams contains parameters of the Repository.CancelOrder
type RepositoryMockCancelOrderParams struct {
	ctx     context.Context
	orderID models.OrderID
}

// RepositoryMockCancelOrderResults contains results of the Repository.CancelOrder
type RepositoryMockCancelOrderResults struct {
	err error
}

// Expect sets up expected params for Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Expect(ctx context.Context, orderID models.OrderID) *mRepositoryMockCancelOrder {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &RepositoryMockCancelOrderExpectation{}
	}

	mmCancelOrder.defaultExpectation.params = &RepositoryMockCancelOrderParams{ctx, orderID}
	for _, e := range mmCancelOrder.expectations {
		if minimock.Equal(e.params, mmCancelOrder.defaultExpectation.params) {
			mmCancelOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelOrder.defaultExpectation.params)
		}
	}

	return mmCancelOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Inspect(f func(ctx context.Context, orderID models.OrderID)) *mRepositoryMockCancelOrder {
	if mmCancelOrder.mock.inspectFuncCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CancelOrder")
	}

	mmCancelOrder.mock.inspectFuncCancelOrder = f

	return mmCancelOrder
}

// Return sets up results that will be returned by Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Return(err error) *RepositoryMock {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &RepositoryMockCancelOrderExpectation{mock: mmCancelOrder.mock}
	}
	mmCancelOrder.defaultExpectation.results = &RepositoryMockCancelOrderResults{err}
	return mmCancelOrder.mock
}

// Set uses given function f to mock the Repository.CancelOrder method
func (mmCancelOrder *mRepositoryMockCancelOrder) Set(f func(ctx context.Context, orderID models.OrderID) (err error)) *RepositoryMock {
	if mmCancelOrder.defaultExpectation != nil {
		mmCancelOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CancelOrder method")
	}

	if len(mmCancelOrder.expectations) > 0 {
		mmCancelOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CancelOrder method")
	}

	mmCancelOrder.mock.funcCancelOrder = f
	return mmCancelOrder.mock
}

// When sets expectation for the Repository.CancelOrder which will trigger the result defined by the following
// Then helper
func (mmCancelOrder *mRepositoryMockCancelOrder) When(ctx context.Context, orderID models.OrderID) *RepositoryMockCancelOrderExpectation {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	expectation := &RepositoryMockCancelOrderExpectation{
		mock:   mmCancelOrder.mock,
		params: &RepositoryMockCancelOrderParams{ctx, orderID},
	}
	mmCancelOrder.expectations = append(mmCancelOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CancelOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCancelOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCancelOrderResults{err}
	return e.mock
}

// CancelOrder implements repository.Repository
func (mmCancelOrder *RepositoryMock) CancelOrder(ctx context.Context, orderID models.OrderID) (err error) {
	mm_atomic.AddUint64(&mmCancelOrder.beforeCancelOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelOrder.afterCancelOrderCounter, 1)

	if mmCancelOrder.inspectFuncCancelOrder != nil {
		mmCancelOrder.inspectFuncCancelOrder(ctx, orderID)
	}

	mm_params := &RepositoryMockCancelOrderParams{ctx, orderID}

	// Record call args
	mmCancelOrder.CancelOrderMock.mutex.Lock()
	mmCancelOrder.CancelOrderMock.callArgs = append(mmCancelOrder.CancelOrderMock.callArgs, mm_params)
	mmCancelOrder.CancelOrderMock.mutex.Unlock()

	for _, e := range mmCancelOrder.CancelOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelOrder.CancelOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelOrder.CancelOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelOrder.CancelOrderMock.defaultExpectation.params
		mm_got := RepositoryMockCancelOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelOrder.t.Errorf("RepositoryMock.CancelOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelOrder.CancelOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelOrder.t.Fatal("No results are set for the RepositoryMock.CancelOrder")
		}
		return (*mm_results).err
	}
	if mmCancelOrder.funcCancelOrder != nil {
		return mmCancelOrder.funcCancelOrder(ctx, orderID)
	}
	mmCancelOrder.t.Fatalf("Unexpected call to RepositoryMock.CancelOrder. %v %v", ctx, orderID)
	return
}

// CancelOrderAfterCounter returns a count of finished RepositoryMock.CancelOrder invocations
func (mmCancelOrder *RepositoryMock) CancelOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.afterCancelOrderCounter)
}

// CancelOrderBeforeCounter returns a count of RepositoryMock.CancelOrder invocations
func (mmCancelOrder *RepositoryMock) CancelOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.beforeCancelOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CancelOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelOrder *mRepositoryMockCancelOrder) Calls() []*RepositoryMockCancelOrderParams {
	mmCancelOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockCancelOrderParams, len(mmCancelOrder.callArgs))
	copy(argCopy, mmCancelOrder.callArgs)

	mmCancelOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCancelOrderDone returns true if the count of the CancelOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCancelOrderDone() bool {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCancelOrderInspect() {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CancelOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		if m.CancelOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CancelOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CancelOrder with params: %#v", *m.CancelOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CancelOrder")
	}
}

type mRepositoryMockCreateOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateOrderExpectation
	expectations       []*RepositoryMockCreateOrderExpectation

	callArgs []*RepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateOrderExpectation specifies expectation struct of the Repository.CreateOrder
type RepositoryMockCreateOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateOrderParams
	results *RepositoryMockCreateOrderResults
	Counter uint64
}

// RepositoryMockCreateOrderParams contains parameters of the Repository.CreateOrder
type RepositoryMockCreateOrderParams struct {
	ctx         context.Context
	createOrder models.CreateOrder
}

// RepositoryMockCreateOrderResults contains results of the Repository.CreateOrder
type RepositoryMockCreateOrderResults struct {
	o1  models.OrderID
	err error
}

// Expect sets up expected params for Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Expect(ctx context.Context, createOrder models.CreateOrder) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &RepositoryMockCreateOrderParams{ctx, createOrder}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, createOrder models.CreateOrder)) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Return(o1 models.OrderID, err error) *RepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &RepositoryMockCreateOrderResults{o1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Repository.CreateOrder method
func (mmCreateOrder *mRepositoryMockCreateOrder) Set(f func(ctx context.Context, createOrder models.CreateOrder) (o1 models.OrderID, err error)) *RepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Repository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mRepositoryMockCreateOrder) When(ctx context.Context, createOrder models.CreateOrder) *RepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &RepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &RepositoryMockCreateOrderParams{ctx, createOrder},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateOrderExpectation) Then(o1 models.OrderID, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateOrderResults{o1, err}
	return e.mock
}

// CreateOrder implements repository.Repository
func (mmCreateOrder *RepositoryMock) CreateOrder(ctx context.Context, createOrder models.CreateOrder) (o1 models.OrderID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, createOrder)
	}

	mm_params := &RepositoryMockCreateOrderParams{ctx, createOrder}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := RepositoryMockCreateOrderParams{ctx, createOrder}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("RepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the RepositoryMock.CreateOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, createOrder)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to RepositoryMock.CreateOrder. %v %v", ctx, createOrder)
	return
}

// CreateOrderAfterCounter returns a count of finished RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mRepositoryMockCreateOrder) Calls() []*RepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateOrder")
	}
}

type mRepositoryMockGetOrderStatus struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOrderStatusExpectation
	expectations       []*RepositoryMockGetOrderStatusExpectation

	callArgs []*RepositoryMockGetOrderStatusParams
	mutex    sync.RWMutex
}

// RepositoryMockGetOrderStatusExpectation specifies expectation struct of the Repository.GetOrderStatus
type RepositoryMockGetOrderStatusExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetOrderStatusParams
	results *RepositoryMockGetOrderStatusResults
	Counter uint64
}

// RepositoryMockGetOrderStatusParams contains parameters of the Repository.GetOrderStatus
type RepositoryMockGetOrderStatusParams struct {
	ctx     context.Context
	orderID models.OrderID
}

// RepositoryMockGetOrderStatusResults contains results of the Repository.GetOrderStatus
type RepositoryMockGetOrderStatusResults struct {
	s1  models.Status
	err error
}

// Expect sets up expected params for Repository.GetOrderStatus
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) Expect(ctx context.Context, orderID models.OrderID) *mRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("RepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &RepositoryMockGetOrderStatusExpectation{}
	}

	mmGetOrderStatus.defaultExpectation.params = &RepositoryMockGetOrderStatusParams{ctx, orderID}
	for _, e := range mmGetOrderStatus.expectations {
		if minimock.Equal(e.params, mmGetOrderStatus.defaultExpectation.params) {
			mmGetOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderStatus.defaultExpectation.params)
		}
	}

	return mmGetOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetOrderStatus
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) Inspect(f func(ctx context.Context, orderID models.OrderID)) *mRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOrderStatus")
	}

	mmGetOrderStatus.mock.inspectFuncGetOrderStatus = f

	return mmGetOrderStatus
}

// Return sets up results that will be returned by Repository.GetOrderStatus
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) Return(s1 models.Status, err error) *RepositoryMock {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("RepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &RepositoryMockGetOrderStatusExpectation{mock: mmGetOrderStatus.mock}
	}
	mmGetOrderStatus.defaultExpectation.results = &RepositoryMockGetOrderStatusResults{s1, err}
	return mmGetOrderStatus.mock
}

// Set uses given function f to mock the Repository.GetOrderStatus method
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) Set(f func(ctx context.Context, orderID models.OrderID) (s1 models.Status, err error)) *RepositoryMock {
	if mmGetOrderStatus.defaultExpectation != nil {
		mmGetOrderStatus.mock.t.Fatalf("Default expectation is already set for the Repository.GetOrderStatus method")
	}

	if len(mmGetOrderStatus.expectations) > 0 {
		mmGetOrderStatus.mock.t.Fatalf("Some expectations are already set for the Repository.GetOrderStatus method")
	}

	mmGetOrderStatus.mock.funcGetOrderStatus = f
	return mmGetOrderStatus.mock
}

// When sets expectation for the Repository.GetOrderStatus which will trigger the result defined by the following
// Then helper
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) When(ctx context.Context, orderID models.OrderID) *RepositoryMockGetOrderStatusExpectation {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("RepositoryMock.GetOrderStatus mock is already set by Set")
	}

	expectation := &RepositoryMockGetOrderStatusExpectation{
		mock:   mmGetOrderStatus.mock,
		params: &RepositoryMockGetOrderStatusParams{ctx, orderID},
	}
	mmGetOrderStatus.expectations = append(mmGetOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetOrderStatus return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOrderStatusExpectation) Then(s1 models.Status, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOrderStatusResults{s1, err}
	return e.mock
}

// GetOrderStatus implements repository.Repository
func (mmGetOrderStatus *RepositoryMock) GetOrderStatus(ctx context.Context, orderID models.OrderID) (s1 models.Status, err error) {
	mm_atomic.AddUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderStatus.afterGetOrderStatusCounter, 1)

	if mmGetOrderStatus.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.inspectFuncGetOrderStatus(ctx, orderID)
	}

	mm_params := &RepositoryMockGetOrderStatusParams{ctx, orderID}

	// Record call args
	mmGetOrderStatus.GetOrderStatusMock.mutex.Lock()
	mmGetOrderStatus.GetOrderStatusMock.callArgs = append(mmGetOrderStatus.GetOrderStatusMock.callArgs, mm_params)
	mmGetOrderStatus.GetOrderStatusMock.mutex.Unlock()

	for _, e := range mmGetOrderStatus.GetOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetOrderStatus.GetOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.params
		mm_got := RepositoryMockGetOrderStatusParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderStatus.t.Errorf("RepositoryMock.GetOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderStatus.t.Fatal("No results are set for the RepositoryMock.GetOrderStatus")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetOrderStatus.funcGetOrderStatus != nil {
		return mmGetOrderStatus.funcGetOrderStatus(ctx, orderID)
	}
	mmGetOrderStatus.t.Fatalf("Unexpected call to RepositoryMock.GetOrderStatus. %v %v", ctx, orderID)
	return
}

// GetOrderStatusAfterCounter returns a count of finished RepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *RepositoryMock) GetOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.afterGetOrderStatusCounter)
}

// GetOrderStatusBeforeCounter returns a count of RepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *RepositoryMock) GetOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderStatus *mRepositoryMockGetOrderStatus) Calls() []*RepositoryMockGetOrderStatusParams {
	mmGetOrderStatus.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOrderStatusParams, len(mmGetOrderStatus.callArgs))
	copy(argCopy, mmGetOrderStatus.callArgs)

	mmGetOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderStatusDone returns true if the count of the GetOrderStatus invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOrderStatusDone() bool {
	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderStatus != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderStatusInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOrderStatusInspect() {
	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		if m.GetOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetOrderStatus")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderStatus with params: %#v", *m.GetOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderStatus != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetOrderStatus")
	}
}

type mRepositoryMockGetOrderUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOrderUserExpectation
	expectations       []*RepositoryMockGetOrderUserExpectation

	callArgs []*RepositoryMockGetOrderUserParams
	mutex    sync.RWMutex
}

// RepositoryMockGetOrderUserExpectation specifies expectation struct of the Repository.GetOrderUser
type RepositoryMockGetOrderUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetOrderUserParams
	results *RepositoryMockGetOrderUserResults
	Counter uint64
}

// RepositoryMockGetOrderUserParams contains parameters of the Repository.GetOrderUser
type RepositoryMockGetOrderUserParams struct {
	ctx     context.Context
	orderID models.OrderID
}

// RepositoryMockGetOrderUserResults contains results of the Repository.GetOrderUser
type RepositoryMockGetOrderUserResults struct {
	u1  models.User
	err error
}

// Expect sets up expected params for Repository.GetOrderUser
func (mmGetOrderUser *mRepositoryMockGetOrderUser) Expect(ctx context.Context, orderID models.OrderID) *mRepositoryMockGetOrderUser {
	if mmGetOrderUser.mock.funcGetOrderUser != nil {
		mmGetOrderUser.mock.t.Fatalf("RepositoryMock.GetOrderUser mock is already set by Set")
	}

	if mmGetOrderUser.defaultExpectation == nil {
		mmGetOrderUser.defaultExpectation = &RepositoryMockGetOrderUserExpectation{}
	}

	mmGetOrderUser.defaultExpectation.params = &RepositoryMockGetOrderUserParams{ctx, orderID}
	for _, e := range mmGetOrderUser.expectations {
		if minimock.Equal(e.params, mmGetOrderUser.defaultExpectation.params) {
			mmGetOrderUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderUser.defaultExpectation.params)
		}
	}

	return mmGetOrderUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetOrderUser
func (mmGetOrderUser *mRepositoryMockGetOrderUser) Inspect(f func(ctx context.Context, orderID models.OrderID)) *mRepositoryMockGetOrderUser {
	if mmGetOrderUser.mock.inspectFuncGetOrderUser != nil {
		mmGetOrderUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOrderUser")
	}

	mmGetOrderUser.mock.inspectFuncGetOrderUser = f

	return mmGetOrderUser
}

// Return sets up results that will be returned by Repository.GetOrderUser
func (mmGetOrderUser *mRepositoryMockGetOrderUser) Return(u1 models.User, err error) *RepositoryMock {
	if mmGetOrderUser.mock.funcGetOrderUser != nil {
		mmGetOrderUser.mock.t.Fatalf("RepositoryMock.GetOrderUser mock is already set by Set")
	}

	if mmGetOrderUser.defaultExpectation == nil {
		mmGetOrderUser.defaultExpectation = &RepositoryMockGetOrderUserExpectation{mock: mmGetOrderUser.mock}
	}
	mmGetOrderUser.defaultExpectation.results = &RepositoryMockGetOrderUserResults{u1, err}
	return mmGetOrderUser.mock
}

// Set uses given function f to mock the Repository.GetOrderUser method
func (mmGetOrderUser *mRepositoryMockGetOrderUser) Set(f func(ctx context.Context, orderID models.OrderID) (u1 models.User, err error)) *RepositoryMock {
	if mmGetOrderUser.defaultExpectation != nil {
		mmGetOrderUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetOrderUser method")
	}

	if len(mmGetOrderUser.expectations) > 0 {
		mmGetOrderUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetOrderUser method")
	}

	mmGetOrderUser.mock.funcGetOrderUser = f
	return mmGetOrderUser.mock
}

// When sets expectation for the Repository.GetOrderUser which will trigger the result defined by the following
// Then helper
func (mmGetOrderUser *mRepositoryMockGetOrderUser) When(ctx context.Context, orderID models.OrderID) *RepositoryMockGetOrderUserExpectation {
	if mmGetOrderUser.mock.funcGetOrderUser != nil {
		mmGetOrderUser.mock.t.Fatalf("RepositoryMock.GetOrderUser mock is already set by Set")
	}

	expectation := &RepositoryMockGetOrderUserExpectation{
		mock:   mmGetOrderUser.mock,
		params: &RepositoryMockGetOrderUserParams{ctx, orderID},
	}
	mmGetOrderUser.expectations = append(mmGetOrderUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetOrderUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOrderUserExpectation) Then(u1 models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOrderUserResults{u1, err}
	return e.mock
}

// GetOrderUser implements repository.Repository
func (mmGetOrderUser *RepositoryMock) GetOrderUser(ctx context.Context, orderID models.OrderID) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmGetOrderUser.beforeGetOrderUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderUser.afterGetOrderUserCounter, 1)

	if mmGetOrderUser.inspectFuncGetOrderUser != nil {
		mmGetOrderUser.inspectFuncGetOrderUser(ctx, orderID)
	}

	mm_params := &RepositoryMockGetOrderUserParams{ctx, orderID}

	// Record call args
	mmGetOrderUser.GetOrderUserMock.mutex.Lock()
	mmGetOrderUser.GetOrderUserMock.callArgs = append(mmGetOrderUser.GetOrderUserMock.callArgs, mm_params)
	mmGetOrderUser.GetOrderUserMock.mutex.Unlock()

	for _, e := range mmGetOrderUser.GetOrderUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetOrderUser.GetOrderUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderUser.GetOrderUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderUser.GetOrderUserMock.defaultExpectation.params
		mm_got := RepositoryMockGetOrderUserParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderUser.t.Errorf("RepositoryMock.GetOrderUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderUser.GetOrderUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderUser.t.Fatal("No results are set for the RepositoryMock.GetOrderUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetOrderUser.funcGetOrderUser != nil {
		return mmGetOrderUser.funcGetOrderUser(ctx, orderID)
	}
	mmGetOrderUser.t.Fatalf("Unexpected call to RepositoryMock.GetOrderUser. %v %v", ctx, orderID)
	return
}

// GetOrderUserAfterCounter returns a count of finished RepositoryMock.GetOrderUser invocations
func (mmGetOrderUser *RepositoryMock) GetOrderUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderUser.afterGetOrderUserCounter)
}

// GetOrderUserBeforeCounter returns a count of RepositoryMock.GetOrderUser invocations
func (mmGetOrderUser *RepositoryMock) GetOrderUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderUser.beforeGetOrderUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOrderUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderUser *mRepositoryMockGetOrderUser) Calls() []*RepositoryMockGetOrderUserParams {
	mmGetOrderUser.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOrderUserParams, len(mmGetOrderUser.callArgs))
	copy(argCopy, mmGetOrderUser.callArgs)

	mmGetOrderUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderUserDone returns true if the count of the GetOrderUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOrderUserDone() bool {
	for _, e := range m.GetOrderUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderUser != nil && mm_atomic.LoadUint64(&m.afterGetOrderUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOrderUserInspect() {
	for _, e := range m.GetOrderUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderUserCounter) < 1 {
		if m.GetOrderUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetOrderUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderUser with params: %#v", *m.GetOrderUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderUser != nil && mm_atomic.LoadUint64(&m.afterGetOrderUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetOrderUser")
	}
}

type mRepositoryMockGetOutbox struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOutboxExpectation
	expectations       []*RepositoryMockGetOutboxExpectation

	callArgs []*RepositoryMockGetOutboxParams
	mutex    sync.RWMutex
}

// RepositoryMockGetOutboxExpectation specifies expectation struct of the Repository.GetOutbox
type RepositoryMockGetOutboxExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetOutboxParams
	results *RepositoryMockGetOutboxResults
	Counter uint64
}

// RepositoryMockGetOutboxParams contains parameters of the Repository.GetOutbox
type RepositoryMockGetOutboxParams struct {
	ctx context.Context
}

// RepositoryMockGetOutboxResults contains results of the Repository.GetOutbox
type RepositoryMockGetOutboxResults struct {
	oa1 []models.Outbox
	err error
}

// Expect sets up expected params for Repository.GetOutbox
func (mmGetOutbox *mRepositoryMockGetOutbox) Expect(ctx context.Context) *mRepositoryMockGetOutbox {
	if mmGetOutbox.mock.funcGetOutbox != nil {
		mmGetOutbox.mock.t.Fatalf("RepositoryMock.GetOutbox mock is already set by Set")
	}

	if mmGetOutbox.defaultExpectation == nil {
		mmGetOutbox.defaultExpectation = &RepositoryMockGetOutboxExpectation{}
	}

	mmGetOutbox.defaultExpectation.params = &RepositoryMockGetOutboxParams{ctx}
	for _, e := range mmGetOutbox.expectations {
		if minimock.Equal(e.params, mmGetOutbox.defaultExpectation.params) {
			mmGetOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOutbox.defaultExpectation.params)
		}
	}

	return mmGetOutbox
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetOutbox
func (mmGetOutbox *mRepositoryMockGetOutbox) Inspect(f func(ctx context.Context)) *mRepositoryMockGetOutbox {
	if mmGetOutbox.mock.inspectFuncGetOutbox != nil {
		mmGetOutbox.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOutbox")
	}

	mmGetOutbox.mock.inspectFuncGetOutbox = f

	return mmGetOutbox
}

// Return sets up results that will be returned by Repository.GetOutbox
func (mmGetOutbox *mRepositoryMockGetOutbox) Return(oa1 []models.Outbox, err error) *RepositoryMock {
	if mmGetOutbox.mock.funcGetOutbox != nil {
		mmGetOutbox.mock.t.Fatalf("RepositoryMock.GetOutbox mock is already set by Set")
	}

	if mmGetOutbox.defaultExpectation == nil {
		mmGetOutbox.defaultExpectation = &RepositoryMockGetOutboxExpectation{mock: mmGetOutbox.mock}
	}
	mmGetOutbox.defaultExpectation.results = &RepositoryMockGetOutboxResults{oa1, err}
	return mmGetOutbox.mock
}

// Set uses given function f to mock the Repository.GetOutbox method
func (mmGetOutbox *mRepositoryMockGetOutbox) Set(f func(ctx context.Context) (oa1 []models.Outbox, err error)) *RepositoryMock {
	if mmGetOutbox.defaultExpectation != nil {
		mmGetOutbox.mock.t.Fatalf("Default expectation is already set for the Repository.GetOutbox method")
	}

	if len(mmGetOutbox.expectations) > 0 {
		mmGetOutbox.mock.t.Fatalf("Some expectations are already set for the Repository.GetOutbox method")
	}

	mmGetOutbox.mock.funcGetOutbox = f
	return mmGetOutbox.mock
}

// When sets expectation for the Repository.GetOutbox which will trigger the result defined by the following
// Then helper
func (mmGetOutbox *mRepositoryMockGetOutbox) When(ctx context.Context) *RepositoryMockGetOutboxExpectation {
	if mmGetOutbox.mock.funcGetOutbox != nil {
		mmGetOutbox.mock.t.Fatalf("RepositoryMock.GetOutbox mock is already set by Set")
	}

	expectation := &RepositoryMockGetOutboxExpectation{
		mock:   mmGetOutbox.mock,
		params: &RepositoryMockGetOutboxParams{ctx},
	}
	mmGetOutbox.expectations = append(mmGetOutbox.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetOutbox return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOutboxExpectation) Then(oa1 []models.Outbox, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOutboxResults{oa1, err}
	return e.mock
}

// GetOutbox implements repository.Repository
func (mmGetOutbox *RepositoryMock) GetOutbox(ctx context.Context) (oa1 []models.Outbox, err error) {
	mm_atomic.AddUint64(&mmGetOutbox.beforeGetOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOutbox.afterGetOutboxCounter, 1)

	if mmGetOutbox.inspectFuncGetOutbox != nil {
		mmGetOutbox.inspectFuncGetOutbox(ctx)
	}

	mm_params := &RepositoryMockGetOutboxParams{ctx}

	// Record call args
	mmGetOutbox.GetOutboxMock.mutex.Lock()
	mmGetOutbox.GetOutboxMock.callArgs = append(mmGetOutbox.GetOutboxMock.callArgs, mm_params)
	mmGetOutbox.GetOutboxMock.mutex.Unlock()

	for _, e := range mmGetOutbox.GetOutboxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOutbox.GetOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOutbox.GetOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOutbox.GetOutboxMock.defaultExpectation.params
		mm_got := RepositoryMockGetOutboxParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOutbox.t.Errorf("RepositoryMock.GetOutbox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOutbox.GetOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOutbox.t.Fatal("No results are set for the RepositoryMock.GetOutbox")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOutbox.funcGetOutbox != nil {
		return mmGetOutbox.funcGetOutbox(ctx)
	}
	mmGetOutbox.t.Fatalf("Unexpected call to RepositoryMock.GetOutbox. %v", ctx)
	return
}

// GetOutboxAfterCounter returns a count of finished RepositoryMock.GetOutbox invocations
func (mmGetOutbox *RepositoryMock) GetOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOutbox.afterGetOutboxCounter)
}

// GetOutboxBeforeCounter returns a count of RepositoryMock.GetOutbox invocations
func (mmGetOutbox *RepositoryMock) GetOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOutbox.beforeGetOutboxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOutbox *mRepositoryMockGetOutbox) Calls() []*RepositoryMockGetOutboxParams {
	mmGetOutbox.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOutboxParams, len(mmGetOutbox.callArgs))
	copy(argCopy, mmGetOutbox.callArgs)

	mmGetOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockGetOutboxDone returns true if the count of the GetOutbox invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOutboxDone() bool {
	for _, e := range m.GetOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOutboxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOutbox != nil && mm_atomic.LoadUint64(&m.afterGetOutboxCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOutboxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOutboxInspect() {
	for _, e := range m.GetOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOutbox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOutboxCounter) < 1 {
		if m.GetOutboxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetOutbox")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOutbox with params: %#v", *m.GetOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOutbox != nil && mm_atomic.LoadUint64(&m.afterGetOutboxCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetOutbox")
	}
}

type mRepositoryMockGetStocks struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetStocksExpectation
	expectations       []*RepositoryMockGetStocksExpectation

	callArgs []*RepositoryMockGetStocksParams
	mutex    sync.RWMutex
}

// RepositoryMockGetStocksExpectation specifies expectation struct of the Repository.GetStocks
type RepositoryMockGetStocksExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetStocksParams
	results *RepositoryMockGetStocksResults
	Counter uint64
}

// RepositoryMockGetStocksParams contains parameters of the Repository.GetStocks
type RepositoryMockGetStocksParams struct {
	ctx context.Context
	sku uint32
}

// RepositoryMockGetStocksResults contains results of the Repository.GetStocks
type RepositoryMockGetStocksResults struct {
	sp1 *models.Stocks
	err error
}

// Expect sets up expected params for Repository.GetStocks
func (mmGetStocks *mRepositoryMockGetStocks) Expect(ctx context.Context, sku uint32) *mRepositoryMockGetStocks {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("RepositoryMock.GetStocks mock is already set by Set")
	}

	if mmGetStocks.defaultExpectation == nil {
		mmGetStocks.defaultExpectation = &RepositoryMockGetStocksExpectation{}
	}

	mmGetStocks.defaultExpectation.params = &RepositoryMockGetStocksParams{ctx, sku}
	for _, e := range mmGetStocks.expectations {
		if minimock.Equal(e.params, mmGetStocks.defaultExpectation.params) {
			mmGetStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocks.defaultExpectation.params)
		}
	}

	return mmGetStocks
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetStocks
func (mmGetStocks *mRepositoryMockGetStocks) Inspect(f func(ctx context.Context, sku uint32)) *mRepositoryMockGetStocks {
	if mmGetStocks.mock.inspectFuncGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetStocks")
	}

	mmGetStocks.mock.inspectFuncGetStocks = f

	return mmGetStocks
}

// Return sets up results that will be returned by Repository.GetStocks
func (mmGetStocks *mRepositoryMockGetStocks) Return(sp1 *models.Stocks, err error) *RepositoryMock {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("RepositoryMock.GetStocks mock is already set by Set")
	}

	if mmGetStocks.defaultExpectation == nil {
		mmGetStocks.defaultExpectation = &RepositoryMockGetStocksExpectation{mock: mmGetStocks.mock}
	}
	mmGetStocks.defaultExpectation.results = &RepositoryMockGetStocksResults{sp1, err}
	return mmGetStocks.mock
}

// Set uses given function f to mock the Repository.GetStocks method
func (mmGetStocks *mRepositoryMockGetStocks) Set(f func(ctx context.Context, sku uint32) (sp1 *models.Stocks, err error)) *RepositoryMock {
	if mmGetStocks.defaultExpectation != nil {
		mmGetStocks.mock.t.Fatalf("Default expectation is already set for the Repository.GetStocks method")
	}

	if len(mmGetStocks.expectations) > 0 {
		mmGetStocks.mock.t.Fatalf("Some expectations are already set for the Repository.GetStocks method")
	}

	mmGetStocks.mock.funcGetStocks = f
	return mmGetStocks.mock
}

// When sets expectation for the Repository.GetStocks which will trigger the result defined by the following
// Then helper
func (mmGetStocks *mRepositoryMockGetStocks) When(ctx context.Context, sku uint32) *RepositoryMockGetStocksExpectation {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("RepositoryMock.GetStocks mock is already set by Set")
	}

	expectation := &RepositoryMockGetStocksExpectation{
		mock:   mmGetStocks.mock,
		params: &RepositoryMockGetStocksParams{ctx, sku},
	}
	mmGetStocks.expectations = append(mmGetStocks.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetStocks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetStocksExpectation) Then(sp1 *models.Stocks, err error) *RepositoryMock {
	e.results = &RepositoryMockGetStocksResults{sp1, err}
	return e.mock
}

// GetStocks implements repository.Repository
func (mmGetStocks *RepositoryMock) GetStocks(ctx context.Context, sku uint32) (sp1 *models.Stocks, err error) {
	mm_atomic.AddUint64(&mmGetStocks.beforeGetStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocks.afterGetStocksCounter, 1)

	if mmGetStocks.inspectFuncGetStocks != nil {
		mmGetStocks.inspectFuncGetStocks(ctx, sku)
	}

	mm_params := &RepositoryMockGetStocksParams{ctx, sku}

	// Record call args
	mmGetStocks.GetStocksMock.mutex.Lock()
	mmGetStocks.GetStocksMock.callArgs = append(mmGetStocks.GetStocksMock.callArgs, mm_params)
	mmGetStocks.GetStocksMock.mutex.Unlock()

	for _, e := range mmGetStocks.GetStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetStocks.GetStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocks.GetStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocks.GetStocksMock.defaultExpectation.params
		mm_got := RepositoryMockGetStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocks.t.Errorf("RepositoryMock.GetStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocks.GetStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocks.t.Fatal("No results are set for the RepositoryMock.GetStocks")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetStocks.funcGetStocks != nil {
		return mmGetStocks.funcGetStocks(ctx, sku)
	}
	mmGetStocks.t.Fatalf("Unexpected call to RepositoryMock.GetStocks. %v %v", ctx, sku)
	return
}

// GetStocksAfterCounter returns a count of finished RepositoryMock.GetStocks invocations
func (mmGetStocks *RepositoryMock) GetStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocks.afterGetStocksCounter)
}

// GetStocksBeforeCounter returns a count of RepositoryMock.GetStocks invocations
func (mmGetStocks *RepositoryMock) GetStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocks.beforeGetStocksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocks *mRepositoryMockGetStocks) Calls() []*RepositoryMockGetStocksParams {
	mmGetStocks.mutex.RLock()

	argCopy := make([]*RepositoryMockGetStocksParams, len(mmGetStocks.callArgs))
	copy(argCopy, mmGetStocks.callArgs)

	mmGetStocks.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksDone returns true if the count of the GetStocks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetStocksDone() bool {
	for _, e := range m.GetStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocks != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStocksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetStocksInspect() {
	for _, e := range m.GetStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		if m.GetStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetStocks")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetStocks with params: %#v", *m.GetStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocks != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetStocks")
	}
}

type mRepositoryMockGetUnpayedOrdersWithinTimeout struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation
	expectations       []*RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation

	callArgs []*RepositoryMockGetUnpayedOrdersWithinTimeoutParams
	mutex    sync.RWMutex
}

// RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation specifies expectation struct of the Repository.GetUnpayedOrdersWithinTimeout
type RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetUnpayedOrdersWithinTimeoutParams
	results *RepositoryMockGetUnpayedOrdersWithinTimeoutResults
	Counter uint64
}

// RepositoryMockGetUnpayedOrdersWithinTimeoutParams contains parameters of the Repository.GetUnpayedOrdersWithinTimeout
type RepositoryMockGetUnpayedOrdersWithinTimeoutParams struct {
	ctx context.Context
}

// RepositoryMockGetUnpayedOrdersWithinTimeoutResults contains results of the Repository.GetUnpayedOrdersWithinTimeout
type RepositoryMockGetUnpayedOrdersWithinTimeoutResults struct {
	oa1 []models.OrderID
	err error
}

// Expect sets up expected params for Repository.GetUnpayedOrdersWithinTimeout
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) Expect(ctx context.Context) *mRepositoryMockGetUnpayedOrdersWithinTimeout {
	if mmGetUnpayedOrdersWithinTimeout.mock.funcGetUnpayedOrdersWithinTimeout != nil {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("RepositoryMock.GetUnpayedOrdersWithinTimeout mock is already set by Set")
	}

	if mmGetUnpayedOrdersWithinTimeout.defaultExpectation == nil {
		mmGetUnpayedOrdersWithinTimeout.defaultExpectation = &RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation{}
	}

	mmGetUnpayedOrdersWithinTimeout.defaultExpectation.params = &RepositoryMockGetUnpayedOrdersWithinTimeoutParams{ctx}
	for _, e := range mmGetUnpayedOrdersWithinTimeout.expectations {
		if minimock.Equal(e.params, mmGetUnpayedOrdersWithinTimeout.defaultExpectation.params) {
			mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUnpayedOrdersWithinTimeout.defaultExpectation.params)
		}
	}

	return mmGetUnpayedOrdersWithinTimeout
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUnpayedOrdersWithinTimeout
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) Inspect(f func(ctx context.Context)) *mRepositoryMockGetUnpayedOrdersWithinTimeout {
	if mmGetUnpayedOrdersWithinTimeout.mock.inspectFuncGetUnpayedOrdersWithinTimeout != nil {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUnpayedOrdersWithinTimeout")
	}

	mmGetUnpayedOrdersWithinTimeout.mock.inspectFuncGetUnpayedOrdersWithinTimeout = f

	return mmGetUnpayedOrdersWithinTimeout
}

// Return sets up results that will be returned by Repository.GetUnpayedOrdersWithinTimeout
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) Return(oa1 []models.OrderID, err error) *RepositoryMock {
	if mmGetUnpayedOrdersWithinTimeout.mock.funcGetUnpayedOrdersWithinTimeout != nil {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("RepositoryMock.GetUnpayedOrdersWithinTimeout mock is already set by Set")
	}

	if mmGetUnpayedOrdersWithinTimeout.defaultExpectation == nil {
		mmGetUnpayedOrdersWithinTimeout.defaultExpectation = &RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation{mock: mmGetUnpayedOrdersWithinTimeout.mock}
	}
	mmGetUnpayedOrdersWithinTimeout.defaultExpectation.results = &RepositoryMockGetUnpayedOrdersWithinTimeoutResults{oa1, err}
	return mmGetUnpayedOrdersWithinTimeout.mock
}

// Set uses given function f to mock the Repository.GetUnpayedOrdersWithinTimeout method
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) Set(f func(ctx context.Context) (oa1 []models.OrderID, err error)) *RepositoryMock {
	if mmGetUnpayedOrdersWithinTimeout.defaultExpectation != nil {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("Default expectation is already set for the Repository.GetUnpayedOrdersWithinTimeout method")
	}

	if len(mmGetUnpayedOrdersWithinTimeout.expectations) > 0 {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("Some expectations are already set for the Repository.GetUnpayedOrdersWithinTimeout method")
	}

	mmGetUnpayedOrdersWithinTimeout.mock.funcGetUnpayedOrdersWithinTimeout = f
	return mmGetUnpayedOrdersWithinTimeout.mock
}

// When sets expectation for the Repository.GetUnpayedOrdersWithinTimeout which will trigger the result defined by the following
// Then helper
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) When(ctx context.Context) *RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation {
	if mmGetUnpayedOrdersWithinTimeout.mock.funcGetUnpayedOrdersWithinTimeout != nil {
		mmGetUnpayedOrdersWithinTimeout.mock.t.Fatalf("RepositoryMock.GetUnpayedOrdersWithinTimeout mock is already set by Set")
	}

	expectation := &RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation{
		mock:   mmGetUnpayedOrdersWithinTimeout.mock,
		params: &RepositoryMockGetUnpayedOrdersWithinTimeoutParams{ctx},
	}
	mmGetUnpayedOrdersWithinTimeout.expectations = append(mmGetUnpayedOrdersWithinTimeout.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUnpayedOrdersWithinTimeout return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUnpayedOrdersWithinTimeoutExpectation) Then(oa1 []models.OrderID, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUnpayedOrdersWithinTimeoutResults{oa1, err}
	return e.mock
}

// GetUnpayedOrdersWithinTimeout implements repository.Repository
func (mmGetUnpayedOrdersWithinTimeout *RepositoryMock) GetUnpayedOrdersWithinTimeout(ctx context.Context) (oa1 []models.OrderID, err error) {
	mm_atomic.AddUint64(&mmGetUnpayedOrdersWithinTimeout.beforeGetUnpayedOrdersWithinTimeoutCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUnpayedOrdersWithinTimeout.afterGetUnpayedOrdersWithinTimeoutCounter, 1)

	if mmGetUnpayedOrdersWithinTimeout.inspectFuncGetUnpayedOrdersWithinTimeout != nil {
		mmGetUnpayedOrdersWithinTimeout.inspectFuncGetUnpayedOrdersWithinTimeout(ctx)
	}

	mm_params := &RepositoryMockGetUnpayedOrdersWithinTimeoutParams{ctx}

	// Record call args
	mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.mutex.Lock()
	mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.callArgs = append(mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.callArgs, mm_params)
	mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.mutex.Unlock()

	for _, e := range mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation.params
		mm_got := RepositoryMockGetUnpayedOrdersWithinTimeoutParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUnpayedOrdersWithinTimeout.t.Errorf("RepositoryMock.GetUnpayedOrdersWithinTimeout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUnpayedOrdersWithinTimeout.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUnpayedOrdersWithinTimeout.t.Fatal("No results are set for the RepositoryMock.GetUnpayedOrdersWithinTimeout")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetUnpayedOrdersWithinTimeout.funcGetUnpayedOrdersWithinTimeout != nil {
		return mmGetUnpayedOrdersWithinTimeout.funcGetUnpayedOrdersWithinTimeout(ctx)
	}
	mmGetUnpayedOrdersWithinTimeout.t.Fatalf("Unexpected call to RepositoryMock.GetUnpayedOrdersWithinTimeout. %v", ctx)
	return
}

// GetUnpayedOrdersWithinTimeoutAfterCounter returns a count of finished RepositoryMock.GetUnpayedOrdersWithinTimeout invocations
func (mmGetUnpayedOrdersWithinTimeout *RepositoryMock) GetUnpayedOrdersWithinTimeoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUnpayedOrdersWithinTimeout.afterGetUnpayedOrdersWithinTimeoutCounter)
}

// GetUnpayedOrdersWithinTimeoutBeforeCounter returns a count of RepositoryMock.GetUnpayedOrdersWithinTimeout invocations
func (mmGetUnpayedOrdersWithinTimeout *RepositoryMock) GetUnpayedOrdersWithinTimeoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUnpayedOrdersWithinTimeout.beforeGetUnpayedOrdersWithinTimeoutCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUnpayedOrdersWithinTimeout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUnpayedOrdersWithinTimeout *mRepositoryMockGetUnpayedOrdersWithinTimeout) Calls() []*RepositoryMockGetUnpayedOrdersWithinTimeoutParams {
	mmGetUnpayedOrdersWithinTimeout.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUnpayedOrdersWithinTimeoutParams, len(mmGetUnpayedOrdersWithinTimeout.callArgs))
	copy(argCopy, mmGetUnpayedOrdersWithinTimeout.callArgs)

	mmGetUnpayedOrdersWithinTimeout.mutex.RUnlock()

	return argCopy
}

// MinimockGetUnpayedOrdersWithinTimeoutDone returns true if the count of the GetUnpayedOrdersWithinTimeout invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUnpayedOrdersWithinTimeoutDone() bool {
	for _, e := range m.GetUnpayedOrdersWithinTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUnpayedOrdersWithinTimeoutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUnpayedOrdersWithinTimeout != nil && mm_atomic.LoadUint64(&m.afterGetUnpayedOrdersWithinTimeoutCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUnpayedOrdersWithinTimeoutInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUnpayedOrdersWithinTimeoutInspect() {
	for _, e := range m.GetUnpayedOrdersWithinTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUnpayedOrdersWithinTimeout with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUnpayedOrdersWithinTimeoutCounter) < 1 {
		if m.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetUnpayedOrdersWithinTimeout")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUnpayedOrdersWithinTimeout with params: %#v", *m.GetUnpayedOrdersWithinTimeoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUnpayedOrdersWithinTimeout != nil && mm_atomic.LoadUint64(&m.afterGetUnpayedOrdersWithinTimeoutCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUnpayedOrdersWithinTimeout")
	}
}

type mRepositoryMockListOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListOrderExpectation
	expectations       []*RepositoryMockListOrderExpectation

	callArgs []*RepositoryMockListOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockListOrderExpectation specifies expectation struct of the Repository.ListOrder
type RepositoryMockListOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockListOrderParams
	results *RepositoryMockListOrderResults
	Counter uint64
}

// RepositoryMockListOrderParams contains parameters of the Repository.ListOrder
type RepositoryMockListOrderParams struct {
	ctx     context.Context
	orderID models.OrderID
}

// RepositoryMockListOrderResults contains results of the Repository.ListOrder
type RepositoryMockListOrderResults struct {
	op1 *models.Order
	err error
}

// Expect sets up expected params for Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Expect(ctx context.Context, orderID models.OrderID) *mRepositoryMockListOrder {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &RepositoryMockListOrderExpectation{}
	}

	mmListOrder.defaultExpectation.params = &RepositoryMockListOrderParams{ctx, orderID}
	for _, e := range mmListOrder.expectations {
		if minimock.Equal(e.params, mmListOrder.defaultExpectation.params) {
			mmListOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrder.defaultExpectation.params)
		}
	}

	return mmListOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Inspect(f func(ctx context.Context, orderID models.OrderID)) *mRepositoryMockListOrder {
	if mmListOrder.mock.inspectFuncListOrder != nil {
		mmListOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListOrder")
	}

	mmListOrder.mock.inspectFuncListOrder = f

	return mmListOrder
}

// Return sets up results that will be returned by Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Return(op1 *models.Order, err error) *RepositoryMock {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &RepositoryMockListOrderExpectation{mock: mmListOrder.mock}
	}
	mmListOrder.defaultExpectation.results = &RepositoryMockListOrderResults{op1, err}
	return mmListOrder.mock
}

// Set uses given function f to mock the Repository.ListOrder method
func (mmListOrder *mRepositoryMockListOrder) Set(f func(ctx context.Context, orderID models.OrderID) (op1 *models.Order, err error)) *RepositoryMock {
	if mmListOrder.defaultExpectation != nil {
		mmListOrder.mock.t.Fatalf("Default expectation is already set for the Repository.ListOrder method")
	}

	if len(mmListOrder.expectations) > 0 {
		mmListOrder.mock.t.Fatalf("Some expectations are already set for the Repository.ListOrder method")
	}

	mmListOrder.mock.funcListOrder = f
	return mmListOrder.mock
}

// When sets expectation for the Repository.ListOrder which will trigger the result defined by the following
// Then helper
func (mmListOrder *mRepositoryMockListOrder) When(ctx context.Context, orderID models.OrderID) *RepositoryMockListOrderExpectation {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	expectation := &RepositoryMockListOrderExpectation{
		mock:   mmListOrder.mock,
		params: &RepositoryMockListOrderParams{ctx, orderID},
	}
	mmListOrder.expectations = append(mmListOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListOrderExpectation) Then(op1 *models.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockListOrderResults{op1, err}
	return e.mock
}

// ListOrder implements repository.Repository
func (mmListOrder *RepositoryMock) ListOrder(ctx context.Context, orderID models.OrderID) (op1 *models.Order, err error) {
	mm_atomic.AddUint64(&mmListOrder.beforeListOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrder.afterListOrderCounter, 1)

	if mmListOrder.inspectFuncListOrder != nil {
		mmListOrder.inspectFuncListOrder(ctx, orderID)
	}

	mm_params := &RepositoryMockListOrderParams{ctx, orderID}

	// Record call args
	mmListOrder.ListOrderMock.mutex.Lock()
	mmListOrder.ListOrderMock.callArgs = append(mmListOrder.ListOrderMock.callArgs, mm_params)
	mmListOrder.ListOrderMock.mutex.Unlock()

	for _, e := range mmListOrder.ListOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmListOrder.ListOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrder.ListOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrder.ListOrderMock.defaultExpectation.params
		mm_got := RepositoryMockListOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrder.t.Errorf("RepositoryMock.ListOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrder.ListOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrder.t.Fatal("No results are set for the RepositoryMock.ListOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmListOrder.funcListOrder != nil {
		return mmListOrder.funcListOrder(ctx, orderID)
	}
	mmListOrder.t.Fatalf("Unexpected call to RepositoryMock.ListOrder. %v %v", ctx, orderID)
	return
}

// ListOrderAfterCounter returns a count of finished RepositoryMock.ListOrder invocations
func (mmListOrder *RepositoryMock) ListOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.afterListOrderCounter)
}

// ListOrderBeforeCounter returns a count of RepositoryMock.ListOrder invocations
func (mmListOrder *RepositoryMock) ListOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.beforeListOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrder *mRepositoryMockListOrder) Calls() []*RepositoryMockListOrderParams {
	mmListOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockListOrderParams, len(mmListOrder.callArgs))
	copy(argCopy, mmListOrder.callArgs)

	mmListOrder.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderDone returns true if the count of the ListOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListOrderDone() bool {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListOrderInspect() {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		if m.ListOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListOrder with params: %#v", *m.ListOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ListOrder")
	}
}

type mRepositoryMockReduceStock struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReduceStockExpectation
	expectations       []*RepositoryMockReduceStockExpectation

	callArgs []*RepositoryMockReduceStockParams
	mutex    sync.RWMutex
}

// RepositoryMockReduceStockExpectation specifies expectation struct of the Repository.ReduceStock
type RepositoryMockReduceStockExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReduceStockParams
	results *RepositoryMockReduceStockResults
	Counter uint64
}

// RepositoryMockReduceStockParams contains parameters of the Repository.ReduceStock
type RepositoryMockReduceStockParams struct {
	ctx     context.Context
	orderID models.OrderID
}

// RepositoryMockReduceStockResults contains results of the Repository.ReduceStock
type RepositoryMockReduceStockResults struct {
	err error
}

// Expect sets up expected params for Repository.ReduceStock
func (mmReduceStock *mRepositoryMockReduceStock) Expect(ctx context.Context, orderID models.OrderID) *mRepositoryMockReduceStock {
	if mmReduceStock.mock.funcReduceStock != nil {
		mmReduceStock.mock.t.Fatalf("RepositoryMock.ReduceStock mock is already set by Set")
	}

	if mmReduceStock.defaultExpectation == nil {
		mmReduceStock.defaultExpectation = &RepositoryMockReduceStockExpectation{}
	}

	mmReduceStock.defaultExpectation.params = &RepositoryMockReduceStockParams{ctx, orderID}
	for _, e := range mmReduceStock.expectations {
		if minimock.Equal(e.params, mmReduceStock.defaultExpectation.params) {
			mmReduceStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReduceStock.defaultExpectation.params)
		}
	}

	return mmReduceStock
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReduceStock
func (mmReduceStock *mRepositoryMockReduceStock) Inspect(f func(ctx context.Context, orderID models.OrderID)) *mRepositoryMockReduceStock {
	if mmReduceStock.mock.inspectFuncReduceStock != nil {
		mmReduceStock.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReduceStock")
	}

	mmReduceStock.mock.inspectFuncReduceStock = f

	return mmReduceStock
}

// Return sets up results that will be returned by Repository.ReduceStock
func (mmReduceStock *mRepositoryMockReduceStock) Return(err error) *RepositoryMock {
	if mmReduceStock.mock.funcReduceStock != nil {
		mmReduceStock.mock.t.Fatalf("RepositoryMock.ReduceStock mock is already set by Set")
	}

	if mmReduceStock.defaultExpectation == nil {
		mmReduceStock.defaultExpectation = &RepositoryMockReduceStockExpectation{mock: mmReduceStock.mock}
	}
	mmReduceStock.defaultExpectation.results = &RepositoryMockReduceStockResults{err}
	return mmReduceStock.mock
}

// Set uses given function f to mock the Repository.ReduceStock method
func (mmReduceStock *mRepositoryMockReduceStock) Set(f func(ctx context.Context, orderID models.OrderID) (err error)) *RepositoryMock {
	if mmReduceStock.defaultExpectation != nil {
		mmReduceStock.mock.t.Fatalf("Default expectation is already set for the Repository.ReduceStock method")
	}

	if len(mmReduceStock.expectations) > 0 {
		mmReduceStock.mock.t.Fatalf("Some expectations are already set for the Repository.ReduceStock method")
	}

	mmReduceStock.mock.funcReduceStock = f
	return mmReduceStock.mock
}

// When sets expectation for the Repository.ReduceStock which will trigger the result defined by the following
// Then helper
func (mmReduceStock *mRepositoryMockReduceStock) When(ctx context.Context, orderID models.OrderID) *RepositoryMockReduceStockExpectation {
	if mmReduceStock.mock.funcReduceStock != nil {
		mmReduceStock.mock.t.Fatalf("RepositoryMock.ReduceStock mock is already set by Set")
	}

	expectation := &RepositoryMockReduceStockExpectation{
		mock:   mmReduceStock.mock,
		params: &RepositoryMockReduceStockParams{ctx, orderID},
	}
	mmReduceStock.expectations = append(mmReduceStock.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReduceStock return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReduceStockExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReduceStockResults{err}
	return e.mock
}

// ReduceStock implements repository.Repository
func (mmReduceStock *RepositoryMock) ReduceStock(ctx context.Context, orderID models.OrderID) (err error) {
	mm_atomic.AddUint64(&mmReduceStock.beforeReduceStockCounter, 1)
	defer mm_atomic.AddUint64(&mmReduceStock.afterReduceStockCounter, 1)

	if mmReduceStock.inspectFuncReduceStock != nil {
		mmReduceStock.inspectFuncReduceStock(ctx, orderID)
	}

	mm_params := &RepositoryMockReduceStockParams{ctx, orderID}

	// Record call args
	mmReduceStock.ReduceStockMock.mutex.Lock()
	mmReduceStock.ReduceStockMock.callArgs = append(mmReduceStock.ReduceStockMock.callArgs, mm_params)
	mmReduceStock.ReduceStockMock.mutex.Unlock()

	for _, e := range mmReduceStock.ReduceStockMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReduceStock.ReduceStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReduceStock.ReduceStockMock.defaultExpectation.Counter, 1)
		mm_want := mmReduceStock.ReduceStockMock.defaultExpectation.params
		mm_got := RepositoryMockReduceStockParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReduceStock.t.Errorf("RepositoryMock.ReduceStock got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReduceStock.ReduceStockMock.defaultExpectation.results
		if mm_results == nil {
			mmReduceStock.t.Fatal("No results are set for the RepositoryMock.ReduceStock")
		}
		return (*mm_results).err
	}
	if mmReduceStock.funcReduceStock != nil {
		return mmReduceStock.funcReduceStock(ctx, orderID)
	}
	mmReduceStock.t.Fatalf("Unexpected call to RepositoryMock.ReduceStock. %v %v", ctx, orderID)
	return
}

// ReduceStockAfterCounter returns a count of finished RepositoryMock.ReduceStock invocations
func (mmReduceStock *RepositoryMock) ReduceStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceStock.afterReduceStockCounter)
}

// ReduceStockBeforeCounter returns a count of RepositoryMock.ReduceStock invocations
func (mmReduceStock *RepositoryMock) ReduceStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceStock.beforeReduceStockCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReduceStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReduceStock *mRepositoryMockReduceStock) Calls() []*RepositoryMockReduceStockParams {
	mmReduceStock.mutex.RLock()

	argCopy := make([]*RepositoryMockReduceStockParams, len(mmReduceStock.callArgs))
	copy(argCopy, mmReduceStock.callArgs)

	mmReduceStock.mutex.RUnlock()

	return argCopy
}

// MinimockReduceStockDone returns true if the count of the ReduceStock invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReduceStockDone() bool {
	for _, e := range m.ReduceStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReduceStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReduceStockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReduceStock != nil && mm_atomic.LoadUint64(&m.afterReduceStockCounter) < 1 {
		return false
	}
	return true
}

// MinimockReduceStockInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReduceStockInspect() {
	for _, e := range m.ReduceStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReduceStock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReduceStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReduceStockCounter) < 1 {
		if m.ReduceStockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReduceStock")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReduceStock with params: %#v", *m.ReduceStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReduceStock != nil && mm_atomic.LoadUint64(&m.afterReduceStockCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReduceStock")
	}
}

type mRepositoryMockReserveStocks struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReserveStocksExpectation
	expectations       []*RepositoryMockReserveStocksExpectation

	callArgs []*RepositoryMockReserveStocksParams
	mutex    sync.RWMutex
}

// RepositoryMockReserveStocksExpectation specifies expectation struct of the Repository.ReserveStocks
type RepositoryMockReserveStocksExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReserveStocksParams
	results *RepositoryMockReserveStocksResults
	Counter uint64
}

// RepositoryMockReserveStocksParams contains parameters of the Repository.ReserveStocks
type RepositoryMockReserveStocksParams struct {
	ctx                context.Context
	orderId            models.OrderID
	itemSku            uint32
	needToReserveCount uint64
	warehouseId        models.WarehouseID
}

// RepositoryMockReserveStocksResults contains results of the Repository.ReserveStocks
type RepositoryMockReserveStocksResults struct {
	err error
}

// Expect sets up expected params for Repository.ReserveStocks
func (mmReserveStocks *mRepositoryMockReserveStocks) Expect(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID) *mRepositoryMockReserveStocks {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("RepositoryMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &RepositoryMockReserveStocksExpectation{}
	}

	mmReserveStocks.defaultExpectation.params = &RepositoryMockReserveStocksParams{ctx, orderId, itemSku, needToReserveCount, warehouseId}
	for _, e := range mmReserveStocks.expectations {
		if minimock.Equal(e.params, mmReserveStocks.defaultExpectation.params) {
			mmReserveStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveStocks.defaultExpectation.params)
		}
	}

	return mmReserveStocks
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReserveStocks
func (mmReserveStocks *mRepositoryMockReserveStocks) Inspect(f func(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID)) *mRepositoryMockReserveStocks {
	if mmReserveStocks.mock.inspectFuncReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReserveStocks")
	}

	mmReserveStocks.mock.inspectFuncReserveStocks = f

	return mmReserveStocks
}

// Return sets up results that will be returned by Repository.ReserveStocks
func (mmReserveStocks *mRepositoryMockReserveStocks) Return(err error) *RepositoryMock {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("RepositoryMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &RepositoryMockReserveStocksExpectation{mock: mmReserveStocks.mock}
	}
	mmReserveStocks.defaultExpectation.results = &RepositoryMockReserveStocksResults{err}
	return mmReserveStocks.mock
}

// Set uses given function f to mock the Repository.ReserveStocks method
func (mmReserveStocks *mRepositoryMockReserveStocks) Set(f func(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID) (err error)) *RepositoryMock {
	if mmReserveStocks.defaultExpectation != nil {
		mmReserveStocks.mock.t.Fatalf("Default expectation is already set for the Repository.ReserveStocks method")
	}

	if len(mmReserveStocks.expectations) > 0 {
		mmReserveStocks.mock.t.Fatalf("Some expectations are already set for the Repository.ReserveStocks method")
	}

	mmReserveStocks.mock.funcReserveStocks = f
	return mmReserveStocks.mock
}

// When sets expectation for the Repository.ReserveStocks which will trigger the result defined by the following
// Then helper
func (mmReserveStocks *mRepositoryMockReserveStocks) When(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID) *RepositoryMockReserveStocksExpectation {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("RepositoryMock.ReserveStocks mock is already set by Set")
	}

	expectation := &RepositoryMockReserveStocksExpectation{
		mock:   mmReserveStocks.mock,
		params: &RepositoryMockReserveStocksParams{ctx, orderId, itemSku, needToReserveCount, warehouseId},
	}
	mmReserveStocks.expectations = append(mmReserveStocks.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReserveStocks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReserveStocksExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReserveStocksResults{err}
	return e.mock
}

// ReserveStocks implements repository.Repository
func (mmReserveStocks *RepositoryMock) ReserveStocks(ctx context.Context, orderId models.OrderID, itemSku uint32, needToReserveCount uint64, warehouseId models.WarehouseID) (err error) {
	mm_atomic.AddUint64(&mmReserveStocks.beforeReserveStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveStocks.afterReserveStocksCounter, 1)

	if mmReserveStocks.inspectFuncReserveStocks != nil {
		mmReserveStocks.inspectFuncReserveStocks(ctx, orderId, itemSku, needToReserveCount, warehouseId)
	}

	mm_params := &RepositoryMockReserveStocksParams{ctx, orderId, itemSku, needToReserveCount, warehouseId}

	// Record call args
	mmReserveStocks.ReserveStocksMock.mutex.Lock()
	mmReserveStocks.ReserveStocksMock.callArgs = append(mmReserveStocks.ReserveStocksMock.callArgs, mm_params)
	mmReserveStocks.ReserveStocksMock.mutex.Unlock()

	for _, e := range mmReserveStocks.ReserveStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveStocks.ReserveStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveStocks.ReserveStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveStocks.ReserveStocksMock.defaultExpectation.params
		mm_got := RepositoryMockReserveStocksParams{ctx, orderId, itemSku, needToReserveCount, warehouseId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveStocks.t.Errorf("RepositoryMock.ReserveStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveStocks.ReserveStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveStocks.t.Fatal("No results are set for the RepositoryMock.ReserveStocks")
		}
		return (*mm_results).err
	}
	if mmReserveStocks.funcReserveStocks != nil {
		return mmReserveStocks.funcReserveStocks(ctx, orderId, itemSku, needToReserveCount, warehouseId)
	}
	mmReserveStocks.t.Fatalf("Unexpected call to RepositoryMock.ReserveStocks. %v %v %v %v %v", ctx, orderId, itemSku, needToReserveCount, warehouseId)
	return
}

// ReserveStocksAfterCounter returns a count of finished RepositoryMock.ReserveStocks invocations
func (mmReserveStocks *RepositoryMock) ReserveStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.afterReserveStocksCounter)
}

// ReserveStocksBeforeCounter returns a count of RepositoryMock.ReserveStocks invocations
func (mmReserveStocks *RepositoryMock) ReserveStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.beforeReserveStocksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReserveStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveStocks *mRepositoryMockReserveStocks) Calls() []*RepositoryMockReserveStocksParams {
	mmReserveStocks.mutex.RLock()

	argCopy := make([]*RepositoryMockReserveStocksParams, len(mmReserveStocks.callArgs))
	copy(argCopy, mmReserveStocks.callArgs)

	mmReserveStocks.mutex.RUnlock()

	return argCopy
}

// MinimockReserveStocksDone returns true if the count of the ReserveStocks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReserveStocksDone() bool {
	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStocks != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveStocksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReserveStocksInspect() {
	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReserveStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		if m.ReserveStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReserveStocks")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReserveStocks with params: %#v", *m.ReserveStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStocks != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReserveStocks")
	}
}

type mRepositoryMockSetOutbox struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSetOutboxExpectation
	expectations       []*RepositoryMockSetOutboxExpectation

	callArgs []*RepositoryMockSetOutboxParams
	mutex    sync.RWMutex
}

// RepositoryMockSetOutboxExpectation specifies expectation struct of the Repository.SetOutbox
type RepositoryMockSetOutboxExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockSetOutboxParams
	results *RepositoryMockSetOutboxResults
	Counter uint64
}

// RepositoryMockSetOutboxParams contains parameters of the Repository.SetOutbox
type RepositoryMockSetOutboxParams struct {
	ctx       context.Context
	orderID   models.OrderID
	oldStatus models.Status
	newStatus models.Status
}

// RepositoryMockSetOutboxResults contains results of the Repository.SetOutbox
type RepositoryMockSetOutboxResults struct {
	err error
}

// Expect sets up expected params for Repository.SetOutbox
func (mmSetOutbox *mRepositoryMockSetOutbox) Expect(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status) *mRepositoryMockSetOutbox {
	if mmSetOutbox.mock.funcSetOutbox != nil {
		mmSetOutbox.mock.t.Fatalf("RepositoryMock.SetOutbox mock is already set by Set")
	}

	if mmSetOutbox.defaultExpectation == nil {
		mmSetOutbox.defaultExpectation = &RepositoryMockSetOutboxExpectation{}
	}

	mmSetOutbox.defaultExpectation.params = &RepositoryMockSetOutboxParams{ctx, orderID, oldStatus, newStatus}
	for _, e := range mmSetOutbox.expectations {
		if minimock.Equal(e.params, mmSetOutbox.defaultExpectation.params) {
			mmSetOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOutbox.defaultExpectation.params)
		}
	}

	return mmSetOutbox
}

// Inspect accepts an inspector function that has same arguments as the Repository.SetOutbox
func (mmSetOutbox *mRepositoryMockSetOutbox) Inspect(f func(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status)) *mRepositoryMockSetOutbox {
	if mmSetOutbox.mock.inspectFuncSetOutbox != nil {
		mmSetOutbox.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SetOutbox")
	}

	mmSetOutbox.mock.inspectFuncSetOutbox = f

	return mmSetOutbox
}

// Return sets up results that will be returned by Repository.SetOutbox
func (mmSetOutbox *mRepositoryMockSetOutbox) Return(err error) *RepositoryMock {
	if mmSetOutbox.mock.funcSetOutbox != nil {
		mmSetOutbox.mock.t.Fatalf("RepositoryMock.SetOutbox mock is already set by Set")
	}

	if mmSetOutbox.defaultExpectation == nil {
		mmSetOutbox.defaultExpectation = &RepositoryMockSetOutboxExpectation{mock: mmSetOutbox.mock}
	}
	mmSetOutbox.defaultExpectation.results = &RepositoryMockSetOutboxResults{err}
	return mmSetOutbox.mock
}

// Set uses given function f to mock the Repository.SetOutbox method
func (mmSetOutbox *mRepositoryMockSetOutbox) Set(f func(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status) (err error)) *RepositoryMock {
	if mmSetOutbox.defaultExpectation != nil {
		mmSetOutbox.mock.t.Fatalf("Default expectation is already set for the Repository.SetOutbox method")
	}

	if len(mmSetOutbox.expectations) > 0 {
		mmSetOutbox.mock.t.Fatalf("Some expectations are already set for the Repository.SetOutbox method")
	}

	mmSetOutbox.mock.funcSetOutbox = f
	return mmSetOutbox.mock
}

// When sets expectation for the Repository.SetOutbox which will trigger the result defined by the following
// Then helper
func (mmSetOutbox *mRepositoryMockSetOutbox) When(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status) *RepositoryMockSetOutboxExpectation {
	if mmSetOutbox.mock.funcSetOutbox != nil {
		mmSetOutbox.mock.t.Fatalf("RepositoryMock.SetOutbox mock is already set by Set")
	}

	expectation := &RepositoryMockSetOutboxExpectation{
		mock:   mmSetOutbox.mock,
		params: &RepositoryMockSetOutboxParams{ctx, orderID, oldStatus, newStatus},
	}
	mmSetOutbox.expectations = append(mmSetOutbox.expectations, expectation)
	return expectation
}

// Then sets up Repository.SetOutbox return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSetOutboxExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSetOutboxResults{err}
	return e.mock
}

// SetOutbox implements repository.Repository
func (mmSetOutbox *RepositoryMock) SetOutbox(ctx context.Context, orderID models.OrderID, oldStatus models.Status, newStatus models.Status) (err error) {
	mm_atomic.AddUint64(&mmSetOutbox.beforeSetOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOutbox.afterSetOutboxCounter, 1)

	if mmSetOutbox.inspectFuncSetOutbox != nil {
		mmSetOutbox.inspectFuncSetOutbox(ctx, orderID, oldStatus, newStatus)
	}

	mm_params := &RepositoryMockSetOutboxParams{ctx, orderID, oldStatus, newStatus}

	// Record call args
	mmSetOutbox.SetOutboxMock.mutex.Lock()
	mmSetOutbox.SetOutboxMock.callArgs = append(mmSetOutbox.SetOutboxMock.callArgs, mm_params)
	mmSetOutbox.SetOutboxMock.mutex.Unlock()

	for _, e := range mmSetOutbox.SetOutboxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOutbox.SetOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOutbox.SetOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOutbox.SetOutboxMock.defaultExpectation.params
		mm_got := RepositoryMockSetOutboxParams{ctx, orderID, oldStatus, newStatus}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOutbox.t.Errorf("RepositoryMock.SetOutbox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOutbox.SetOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOutbox.t.Fatal("No results are set for the RepositoryMock.SetOutbox")
		}
		return (*mm_results).err
	}
	if mmSetOutbox.funcSetOutbox != nil {
		return mmSetOutbox.funcSetOutbox(ctx, orderID, oldStatus, newStatus)
	}
	mmSetOutbox.t.Fatalf("Unexpected call to RepositoryMock.SetOutbox. %v %v %v %v", ctx, orderID, oldStatus, newStatus)
	return
}

// SetOutboxAfterCounter returns a count of finished RepositoryMock.SetOutbox invocations
func (mmSetOutbox *RepositoryMock) SetOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOutbox.afterSetOutboxCounter)
}

// SetOutboxBeforeCounter returns a count of RepositoryMock.SetOutbox invocations
func (mmSetOutbox *RepositoryMock) SetOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOutbox.beforeSetOutboxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SetOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOutbox *mRepositoryMockSetOutbox) Calls() []*RepositoryMockSetOutboxParams {
	mmSetOutbox.mutex.RLock()

	argCopy := make([]*RepositoryMockSetOutboxParams, len(mmSetOutbox.callArgs))
	copy(argCopy, mmSetOutbox.callArgs)

	mmSetOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockSetOutboxDone returns true if the count of the SetOutbox invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSetOutboxDone() bool {
	for _, e := range m.SetOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetOutboxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOutbox != nil && mm_atomic.LoadUint64(&m.afterSetOutboxCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetOutboxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSetOutboxInspect() {
	for _, e := range m.SetOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SetOutbox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetOutboxCounter) < 1 {
		if m.SetOutboxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.SetOutbox")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SetOutbox with params: %#v", *m.SetOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOutbox != nil && mm_atomic.LoadUint64(&m.afterSetOutboxCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.SetOutbox")
	}
}

type mRepositoryMockUpdateOrderStatus struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateOrderStatusExpectation
	expectations       []*RepositoryMockUpdateOrderStatusExpectation

	callArgs []*RepositoryMockUpdateOrderStatusParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateOrderStatusExpectation specifies expectation struct of the Repository.UpdateOrderStatus
type RepositoryMockUpdateOrderStatusExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateOrderStatusParams
	results *RepositoryMockUpdateOrderStatusResults
	Counter uint64
}

// RepositoryMockUpdateOrderStatusParams contains parameters of the Repository.UpdateOrderStatus
type RepositoryMockUpdateOrderStatusParams struct {
	ctx     context.Context
	orderID []models.OrderID
	status  models.Status
}

// RepositoryMockUpdateOrderStatusResults contains results of the Repository.UpdateOrderStatus
type RepositoryMockUpdateOrderStatusResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateOrderStatus
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) Expect(ctx context.Context, orderID []models.OrderID, status models.Status) *mRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("RepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &RepositoryMockUpdateOrderStatusExpectation{}
	}

	mmUpdateOrderStatus.defaultExpectation.params = &RepositoryMockUpdateOrderStatusParams{ctx, orderID, status}
	for _, e := range mmUpdateOrderStatus.expectations {
		if minimock.Equal(e.params, mmUpdateOrderStatus.defaultExpectation.params) {
			mmUpdateOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderStatus.defaultExpectation.params)
		}
	}

	return mmUpdateOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateOrderStatus
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) Inspect(f func(ctx context.Context, orderID []models.OrderID, status models.Status)) *mRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateOrderStatus")
	}

	mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus = f

	return mmUpdateOrderStatus
}

// Return sets up results that will be returned by Repository.UpdateOrderStatus
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) Return(err error) *RepositoryMock {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("RepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &RepositoryMockUpdateOrderStatusExpectation{mock: mmUpdateOrderStatus.mock}
	}
	mmUpdateOrderStatus.defaultExpectation.results = &RepositoryMockUpdateOrderStatusResults{err}
	return mmUpdateOrderStatus.mock
}

// Set uses given function f to mock the Repository.UpdateOrderStatus method
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) Set(f func(ctx context.Context, orderID []models.OrderID, status models.Status) (err error)) *RepositoryMock {
	if mmUpdateOrderStatus.defaultExpectation != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateOrderStatus method")
	}

	if len(mmUpdateOrderStatus.expectations) > 0 {
		mmUpdateOrderStatus.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateOrderStatus method")
	}

	mmUpdateOrderStatus.mock.funcUpdateOrderStatus = f
	return mmUpdateOrderStatus.mock
}

// When sets expectation for the Repository.UpdateOrderStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) When(ctx context.Context, orderID []models.OrderID, status models.Status) *RepositoryMockUpdateOrderStatusExpectation {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("RepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateOrderStatusExpectation{
		mock:   mmUpdateOrderStatus.mock,
		params: &RepositoryMockUpdateOrderStatusParams{ctx, orderID, status},
	}
	mmUpdateOrderStatus.expectations = append(mmUpdateOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateOrderStatus return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateOrderStatusExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateOrderStatusResults{err}
	return e.mock
}

// UpdateOrderStatus implements repository.Repository
func (mmUpdateOrderStatus *RepositoryMock) UpdateOrderStatus(ctx context.Context, orderID []models.OrderID, status models.Status) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter, 1)

	if mmUpdateOrderStatus.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.inspectFuncUpdateOrderStatus(ctx, orderID, status)
	}

	mm_params := &RepositoryMockUpdateOrderStatusParams{ctx, orderID, status}

	// Record call args
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Lock()
	mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs = append(mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs, mm_params)
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Unlock()

	for _, e := range mmUpdateOrderStatus.UpdateOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateOrderStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderStatus.t.Errorf("RepositoryMock.UpdateOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderStatus.t.Fatal("No results are set for the RepositoryMock.UpdateOrderStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderStatus.funcUpdateOrderStatus != nil {
		return mmUpdateOrderStatus.funcUpdateOrderStatus(ctx, orderID, status)
	}
	mmUpdateOrderStatus.t.Fatalf("Unexpected call to RepositoryMock.UpdateOrderStatus. %v %v %v", ctx, orderID, status)
	return
}

// UpdateOrderStatusAfterCounter returns a count of finished RepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *RepositoryMock) UpdateOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter)
}

// UpdateOrderStatusBeforeCounter returns a count of RepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *RepositoryMock) UpdateOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderStatus *mRepositoryMockUpdateOrderStatus) Calls() []*RepositoryMockUpdateOrderStatusParams {
	mmUpdateOrderStatus.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateOrderStatusParams, len(mmUpdateOrderStatus.callArgs))
	copy(argCopy, mmUpdateOrderStatus.callArgs)

	mmUpdateOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderStatusDone returns true if the count of the UpdateOrderStatus invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateOrderStatusDone() bool {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderStatusInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateOrderStatusInspect() {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		if m.UpdateOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateOrderStatus")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrderStatus with params: %#v", *m.UpdateOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateOrderStatus")
	}
}

type mRepositoryMockUpdateOutbox struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateOutboxExpectation
	expectations       []*RepositoryMockUpdateOutboxExpectation

	callArgs []*RepositoryMockUpdateOutboxParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateOutboxExpectation specifies expectation struct of the Repository.UpdateOutbox
type RepositoryMockUpdateOutboxExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateOutboxParams
	results *RepositoryMockUpdateOutboxResults
	Counter uint64
}

// RepositoryMockUpdateOutboxParams contains parameters of the Repository.UpdateOutbox
type RepositoryMockUpdateOutboxParams struct {
	ctx context.Context
	ids []models.OutboxID
}

// RepositoryMockUpdateOutboxResults contains results of the Repository.UpdateOutbox
type RepositoryMockUpdateOutboxResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateOutbox
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) Expect(ctx context.Context, ids []models.OutboxID) *mRepositoryMockUpdateOutbox {
	if mmUpdateOutbox.mock.funcUpdateOutbox != nil {
		mmUpdateOutbox.mock.t.Fatalf("RepositoryMock.UpdateOutbox mock is already set by Set")
	}

	if mmUpdateOutbox.defaultExpectation == nil {
		mmUpdateOutbox.defaultExpectation = &RepositoryMockUpdateOutboxExpectation{}
	}

	mmUpdateOutbox.defaultExpectation.params = &RepositoryMockUpdateOutboxParams{ctx, ids}
	for _, e := range mmUpdateOutbox.expectations {
		if minimock.Equal(e.params, mmUpdateOutbox.defaultExpectation.params) {
			mmUpdateOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOutbox.defaultExpectation.params)
		}
	}

	return mmUpdateOutbox
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateOutbox
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) Inspect(f func(ctx context.Context, ids []models.OutboxID)) *mRepositoryMockUpdateOutbox {
	if mmUpdateOutbox.mock.inspectFuncUpdateOutbox != nil {
		mmUpdateOutbox.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateOutbox")
	}

	mmUpdateOutbox.mock.inspectFuncUpdateOutbox = f

	return mmUpdateOutbox
}

// Return sets up results that will be returned by Repository.UpdateOutbox
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) Return(err error) *RepositoryMock {
	if mmUpdateOutbox.mock.funcUpdateOutbox != nil {
		mmUpdateOutbox.mock.t.Fatalf("RepositoryMock.UpdateOutbox mock is already set by Set")
	}

	if mmUpdateOutbox.defaultExpectation == nil {
		mmUpdateOutbox.defaultExpectation = &RepositoryMockUpdateOutboxExpectation{mock: mmUpdateOutbox.mock}
	}
	mmUpdateOutbox.defaultExpectation.results = &RepositoryMockUpdateOutboxResults{err}
	return mmUpdateOutbox.mock
}

// Set uses given function f to mock the Repository.UpdateOutbox method
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) Set(f func(ctx context.Context, ids []models.OutboxID) (err error)) *RepositoryMock {
	if mmUpdateOutbox.defaultExpectation != nil {
		mmUpdateOutbox.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateOutbox method")
	}

	if len(mmUpdateOutbox.expectations) > 0 {
		mmUpdateOutbox.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateOutbox method")
	}

	mmUpdateOutbox.mock.funcUpdateOutbox = f
	return mmUpdateOutbox.mock
}

// When sets expectation for the Repository.UpdateOutbox which will trigger the result defined by the following
// Then helper
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) When(ctx context.Context, ids []models.OutboxID) *RepositoryMockUpdateOutboxExpectation {
	if mmUpdateOutbox.mock.funcUpdateOutbox != nil {
		mmUpdateOutbox.mock.t.Fatalf("RepositoryMock.UpdateOutbox mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateOutboxExpectation{
		mock:   mmUpdateOutbox.mock,
		params: &RepositoryMockUpdateOutboxParams{ctx, ids},
	}
	mmUpdateOutbox.expectations = append(mmUpdateOutbox.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateOutbox return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateOutboxExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateOutboxResults{err}
	return e.mock
}

// UpdateOutbox implements repository.Repository
func (mmUpdateOutbox *RepositoryMock) UpdateOutbox(ctx context.Context, ids []models.OutboxID) (err error) {
	mm_atomic.AddUint64(&mmUpdateOutbox.beforeUpdateOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOutbox.afterUpdateOutboxCounter, 1)

	if mmUpdateOutbox.inspectFuncUpdateOutbox != nil {
		mmUpdateOutbox.inspectFuncUpdateOutbox(ctx, ids)
	}

	mm_params := &RepositoryMockUpdateOutboxParams{ctx, ids}

	// Record call args
	mmUpdateOutbox.UpdateOutboxMock.mutex.Lock()
	mmUpdateOutbox.UpdateOutboxMock.callArgs = append(mmUpdateOutbox.UpdateOutboxMock.callArgs, mm_params)
	mmUpdateOutbox.UpdateOutboxMock.mutex.Unlock()

	for _, e := range mmUpdateOutbox.UpdateOutboxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOutbox.UpdateOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOutbox.UpdateOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOutbox.UpdateOutboxMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateOutboxParams{ctx, ids}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOutbox.t.Errorf("RepositoryMock.UpdateOutbox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOutbox.UpdateOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOutbox.t.Fatal("No results are set for the RepositoryMock.UpdateOutbox")
		}
		return (*mm_results).err
	}
	if mmUpdateOutbox.funcUpdateOutbox != nil {
		return mmUpdateOutbox.funcUpdateOutbox(ctx, ids)
	}
	mmUpdateOutbox.t.Fatalf("Unexpected call to RepositoryMock.UpdateOutbox. %v %v", ctx, ids)
	return
}

// UpdateOutboxAfterCounter returns a count of finished RepositoryMock.UpdateOutbox invocations
func (mmUpdateOutbox *RepositoryMock) UpdateOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOutbox.afterUpdateOutboxCounter)
}

// UpdateOutboxBeforeCounter returns a count of RepositoryMock.UpdateOutbox invocations
func (mmUpdateOutbox *RepositoryMock) UpdateOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOutbox.beforeUpdateOutboxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOutbox *mRepositoryMockUpdateOutbox) Calls() []*RepositoryMockUpdateOutboxParams {
	mmUpdateOutbox.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateOutboxParams, len(mmUpdateOutbox.callArgs))
	copy(argCopy, mmUpdateOutbox.callArgs)

	mmUpdateOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOutboxDone returns true if the count of the UpdateOutbox invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateOutboxDone() bool {
	for _, e := range m.UpdateOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOutboxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOutbox != nil && mm_atomic.LoadUint64(&m.afterUpdateOutboxCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOutboxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateOutboxInspect() {
	for _, e := range m.UpdateOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOutbox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOutboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOutboxCounter) < 1 {
		if m.UpdateOutboxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateOutbox")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOutbox with params: %#v", *m.UpdateOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOutbox != nil && mm_atomic.LoadUint64(&m.afterUpdateOutboxCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateOutbox")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelOrderInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockGetOrderStatusInspect()

		m.MinimockGetOrderUserInspect()

		m.MinimockGetOutboxInspect()

		m.MinimockGetStocksInspect()

		m.MinimockGetUnpayedOrdersWithinTimeoutInspect()

		m.MinimockListOrderInspect()

		m.MinimockReduceStockInspect()

		m.MinimockReserveStocksInspect()

		m.MinimockSetOutboxInspect()

		m.MinimockUpdateOrderStatusInspect()

		m.MinimockUpdateOutboxInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelOrderDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetOrderStatusDone() &&
		m.MinimockGetOrderUserDone() &&
		m.MinimockGetOutboxDone() &&
		m.MinimockGetStocksDone() &&
		m.MinimockGetUnpayedOrdersWithinTimeoutDone() &&
		m.MinimockListOrderDone() &&
		m.MinimockReduceStockDone() &&
		m.MinimockReserveStocksDone() &&
		m.MinimockSetOutboxDone() &&
		m.MinimockUpdateOrderStatusDone() &&
		m.MinimockUpdateOutboxDone()
}
